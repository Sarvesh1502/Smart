const mongoose = require('mongoose');

const doubtSchema = new mongoose.Schema({
  student: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  course: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course',
    required: true
  },
  lecture: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Lecture'
  },
  subject: {
    type: String,
    required: true,
    trim: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true,
    trim: true
  },
  category: {
    type: String,
    enum: ['concept', 'homework', 'exam', 'general', 'technical'],
    default: 'general'
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  },
  status: {
    type: String,
    enum: ['open', 'in_progress', 'resolved', 'closed'],
    default: 'open'
  },
  // AI-generated response
  aiResponse: {
    answer: String,
    confidence: Number,
    sources: [String],
    generatedAt: Date,
    model: String,
    language: {
      type: String,
      default: 'en'
    }
  },
  // Teacher response
  teacherResponse: {
    answer: String,
    answeredBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    answeredAt: Date,
    attachments: [{
      name: String,
      url: String,
      type: String
    }]
  },
  // Peer responses
  peerResponses: [{
    student: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    answer: String,
    answeredAt: Date,
    upvotes: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }],
    downvotes: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    }],
    isAccepted: {
      type: Boolean,
      default: false
    }
  }],
  // Tags for better categorization
  tags: [String],
  // Attachments (images, documents, etc.)
  attachments: [{
    name: String,
    url: String,
    type: String,
    size: Number
  }],
  // Follow-up questions
  followUps: [{
    question: String,
    askedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    askedAt: Date,
    answer: String,
    answeredBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    answeredAt: Date
  }],
  // Analytics
  analytics: {
    views: {
      type: Number,
      default: 0
    },
    helpfulVotes: {
      type: Number,
      default: 0
    },
    notHelpfulVotes: {
      type: Number,
      default: 0
    },
    responseTime: Number, // in minutes
    resolutionTime: Number // in minutes
  },
  // Language support
  language: {
    type: String,
    default: 'en'
  },
  // Translation support
  translations: [{
    language: String,
    title: String,
    description: String,
    aiResponse: {
      answer: String
    },
    teacherResponse: {
      answer: String
    }
  }],
  // Related doubts
  relatedDoubtIds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Doubt'
  }],
  // Auto-generated from lecture
  isAutoGenerated: {
    type: Boolean,
    default: false
  },
  // Source information
  source: {
    type: String,
    enum: ['manual', 'lecture_chat', 'assignment', 'exam'],
    default: 'manual'
  }
}, {
  timestamps: true
});

// Indexes for better performance
doubtSchema.index({ student: 1 });
doubtSchema.index({ course: 1 });
doubtSchema.index({ subject: 1 });
doubtSchema.index({ status: 1 });
doubtSchema.index({ priority: 1 });
doubtSchema.index({ category: 1 });
doubtSchema.index({ createdAt: -1 });
doubtSchema.index({ 'tags': 1 });

// Text search index
doubtSchema.index({
  title: 'text',
  description: 'text',
  'aiResponse.answer': 'text',
  'teacherResponse.answer': 'text'
});

// Virtual for total responses
doubtSchema.virtual('totalResponses').get(function() {
  let count = 0;
  if (this.aiResponse.answer) count++;
  if (this.teacherResponse.answer) count++;
  count += this.peerResponses.length;
  return count;
});

// Virtual for helpful score
doubtSchema.virtual('helpfulScore').get(function() {
  const total = this.analytics.helpfulVotes + this.analytics.notHelpfulVotes;
  return total > 0 ? (this.analytics.helpfulVotes / total) * 100 : 0;
});

// Method to add peer response
doubtSchema.methods.addPeerResponse = function(studentId, answer) {
  this.peerResponses.push({
    student: studentId,
    answer,
    answeredAt: new Date()
  });
  
  // Update status if it was open
  if (this.status === 'open') {
    this.status = 'in_progress';
  }
  
  return this.save();
};

// Method to vote on peer response
doubtSchema.methods.voteOnPeerResponse = function(responseId, userId, voteType) {
  const response = this.peerResponses.id(responseId);
  if (!response) throw new Error('Response not found');
  
  // Remove existing vote
  response.upvotes = response.upvotes.filter(id => !id.equals(userId));
  response.downvotes = response.downvotes.filter(id => !id.equals(userId));
  
  // Add new vote
  if (voteType === 'upvote') {
    response.upvotes.push(userId);
  } else if (voteType === 'downvote') {
    response.downvotes.push(userId);
  }
  
  return this.save();
};

// Method to accept peer response
doubtSchema.methods.acceptPeerResponse = function(responseId, studentId) {
  // Only the original student can accept a response
  if (!this.student.equals(studentId)) {
    throw new Error('Only the original student can accept responses');
  }
  
  // Unaccept all other responses
  this.peerResponses.forEach(response => {
    response.isAccepted = false;
  });
  
  // Accept the selected response
  const response = this.peerResponses.id(responseId);
  if (response) {
    response.isAccepted = true;
    this.status = 'resolved';
  }
  
  return this.save();
};

// Method to add follow-up question
doubtSchema.methods.addFollowUp = function(question, askedBy) {
  this.followUps.push({
    question,
    askedBy,
    askedAt: new Date()
  });
  
  return this.save();
};

// Method to answer follow-up
doubtSchema.methods.answerFollowUp = function(followUpId, answer, answeredBy) {
  const followUp = this.followUps.id(followUpId);
  if (followUp) {
    followUp.answer = answer;
    followUp.answeredBy = answeredBy;
    followUp.answeredAt = new Date();
  }
  
  return this.save();
};

// Method to update analytics
doubtSchema.methods.updateAnalytics = function(type, value = 1) {
  if (this.analytics[type] !== undefined) {
    this.analytics[type] += value;
  }
  return this.save();
};

// Static method to search doubts
doubtSchema.statics.searchDoubts = function(query, filters = {}) {
  const searchQuery = {
    $text: { $search: query }
  };
  
  // Add filters
  if (filters.course) searchQuery.course = filters.course;
  if (filters.subject) searchQuery.subject = filters.subject;
  if (filters.status) searchQuery.status = filters.status;
  if (filters.category) searchQuery.category = filters.category;
  if (filters.priority) searchQuery.priority = filters.priority;
  
  return this.find(searchQuery, { score: { $meta: 'textScore' } })
    .sort({ score: { $meta: 'textScore' } })
    .populate('student', 'name email')
    .populate('course', 'title subject')
    .populate('teacherResponse.answeredBy', 'name')
    .limit(filters.limit || 20);
};

// Static method to get doubt statistics
doubtSchema.statics.getDoubtStats = async function(courseId, dateRange) {
  const matchStage = {};
  if (courseId) matchStage.course = mongoose.Types.ObjectId(courseId);
  if (dateRange) {
    matchStage.createdAt = {
      $gte: dateRange.start,
      $lte: dateRange.end
    };
  }

  const pipeline = [
    { $match: matchStage },
    {
      $group: {
        _id: null,
        totalDoubts: { $sum: 1 },
        openDoubts: {
          $sum: { $cond: [{ $eq: ['$status', 'open'] }, 1, 0] }
        },
        resolvedDoubts: {
          $sum: { $cond: [{ $eq: ['$status', 'resolved'] }, 1, 0] }
        },
        averageResponseTime: { $avg: '$analytics.responseTime' },
        averageResolutionTime: { $avg: '$analytics.resolutionTime' }
      }
    }
  ];

  const result = await this.aggregate(pipeline);
  return result[0] || {
    totalDoubts: 0,
    openDoubts: 0,
    resolvedDoubts: 0,
    averageResponseTime: 0,
    averageResolutionTime: 0
  };
};

module.exports = mongoose.model('Doubt', doubtSchema);
